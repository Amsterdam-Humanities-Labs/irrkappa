Annotator.b <- "T"
Overlap.threshold <- 51
df <- init(tier, replace_value = replace_value)
df.matches <- matches(df)
q <- "01-NeutNeg-01"
plot.matched.annotations(df, q, threshold = FALSE)
plot.matched.annotations(df, q, threshold = TRUE)
confusion.matrices <- confusion.matrix(df.matches)
confusion <- confusion.matrices$confusion
confusion.matrices$confusion.total
agreement <- calculate_agreement(df = confusion,
nmm_values = confusion[confusion$NMM != "unmatched",]$NMM)
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ggplot2)
library(stringr)
library(ggstance)
library(tidyr)
library(irr)
init <- function(tier, replace_value = FALSE) {
file <- paste("annotations/", tier, ".csv",sep="")
df <- read.csv(file, stringsAsFactors = FALSE)
df <- df %>%
# Set up basic structure
rename_all(~ gsub("\\.\\.\\.ss.msec", "", .)) %>%
rename_all(~ gsub("NMM\\..*", "NMM", .)) %>%
mutate(Annotator = case_when(grepl("MO", File) ~ Annotator.a, # Adjust to own annotator label
grepl("TDR", File) ~ Annotator.b,  # Adjust to own annotator label
TRUE ~ NA_character_)) %>%
mutate_at('NMM', ~ str_replace(., "-", ".")) %>%
# Can be adjusted according to own needs, or removed
mutate(NMM = case_when(
replace_value & tier == "eye_shape" & NMM == "closed" ~ "neutral",
replace_value & tier %in% c("lips", "lip_corners") & NMM == "mouth.action" ~ "neutral",
TRUE ~ NMM)) %>%
mutate_if(is.character, as.factor) %>%
# Round times to 0.05 for whole number of frames (necessary for time-based annotations)
mutate(Begin.Time = round(Begin.Time / 0.05) * 0.05,
End.Time = round(End.Time / 0.05) * 0.05) %>%
# Fill time gaps between annotations, find first and last annotation
group_by(Question, Annotator) %>%
arrange(Begin.Time) %>%
mutate(time_diff = lead(Begin.Time) - End.Time) %>%
replace(is.na(.), 0) %>%
mutate(Begin.Time = ifelse(time_diff < 0, Begin.Time + time_diff, Begin.Time),
End.Time = ifelse(time_diff > 0, End.Time + time_diff, End.Time),
Duration = End.Time - Begin.Time,
First.Annotator = ifelse(row_number() == 1, 1, 0),
Last.Annotator = ifelse(row_number() == n(), 1, 0)) %>%
ungroup() %>%
# Ensure that the annotations for each question match in begin and end times
group_by(Question) %>%
mutate(Begin.Time.Min = min(Begin.Time, na.rm = TRUE),
End.Time.Max = max(End.Time, na.rm = TRUE),
Begin.Time = ifelse(((Begin.Time > Begin.Time.Min) & First.Annotator), Begin.Time.Min, Begin.Time),
End.Time = ifelse(((End.Time < End.Time.Max) & Last.Annotator), End.Time.Max, End.Time),
Duration = round(End.Time - Begin.Time, 2)) %>%
ungroup() %>%
# Calculate the frames (using 1-indexing)
mutate(Begin.Frame = ((Begin.Time - Begin.Time.Min) * 60),
End.Frame = Begin.Frame + (Duration * 60),
Frames = Duration * 60) %>%
arrange(Annotator, Question) %>%
mutate(ID = 1:nrow(df)) %>%
select(Question, ID, Annotator, NMM, Begin.Time, End.Time, Duration, Begin.Frame, End.Frame, Frames)
# In the event-based approach, we remove the neutral annotations, as these are not events
df <- filter.drop.levels(df, df$NMM != "neutral")
df$ID <- 1:nrow(df)
return(df)
}
overlap <- function(df) {
overlapping <- df %>%
inner_join(df, by = "Question", suffix = c(".x", ".y")) %>%
select(Question, ID.x, ID.y, NMM.x, NMM.y, Annotator.x, Begin.Frame.x, End.Frame.x, Frames.x, Annotator.y, Begin.Frame.y, End.Frame.y, Frames.y) %>%
mutate(end = pmin(End.Frame.x, End.Frame.y),
begin = pmax(Begin.Frame.x, Begin.Frame.y),
Overlap = round((end - begin) / pmax(Frames.x, Frames.y) * 100, 0),
Overlap.x = round((end - begin) / Frames.x * 100, 0),
Overlap.y = round((end - begin) / Frames.y * 100, 0),
Overlap.frame = round((end - begin), 0), .before = Annotator.x) %>%
filter(Annotator.x != Annotator.y,
End.Frame.x > Begin.Frame.y,
End.Frame.y > Begin.Frame.x,
Overlap > 0) %>%
select(-c(end, begin))
return(overlapping)
}
filter.drop.levels <- function(df, condition) {
df.filtered <- df %>%
filter(condition) %>%
droplevels()
return(df.filtered)
}
matches <- function(df) {
df.overlapping <- suppressWarnings(overlap(df))
df.overlapping.filtered <- filter.drop.levels(df.overlapping, df.overlapping$Overlap >= Overlap.threshold)
df.matches <- df.overlapping.filtered %>%
right_join(df, by = c("Question" = "Question", "ID.x" = "ID", "Annotator.x" = "Annotator", "NMM.x" = "NMM")) %>%
arrange(ID.x) %>%
# Fill in unmatched annotations
mutate(NMM.y = if_else(is.na(NMM.y), "unmatched", NMM.y),
Annotator.y = if_else(is.na(Annotator.y), if_else(Annotator.x == Annotator.a, Annotator.b, Annotator.a), Annotator.y),
ID.y = as.integer(if_else(is.na(ID.y), 0, ID.y))) %>%
# Swap values in ID, NMM, and Annotator columns if Annotator.x is Annotator.b
mutate(swap = if_else(Annotator.x == Annotator.b, TRUE, FALSE),
ID.xx = ID.x,
ID.yy = ID.y,
ID.x = if_else(swap, ID.yy, ID.x),
ID.y = if_else(swap, ID.xx, ID.y),
NMM.xx = NMM.x,
NMM.yy = NMM.y,
NMM.x = if_else(swap, NMM.yy, NMM.x),
NMM.y = if_else(swap, NMM.xx, NMM.y),
Annotator.x = if_else(swap, Annotator.a, Annotator.x),
Annotator.y = if_else(swap, Annotator.b, Annotator.y)) %>%
mutate_if(is.character, as.factor) %>%
select(Question, ID.x, ID.y, NMM.x, NMM.y, Annotator.x, Annotator.y) %>%
distinct()
return(df.matches)
}
confusion.matrix <- function(df) {
categories <- unique(c(levels(df$NMM.x), levels(df$NMM.y)))
combinations <- crossing(NMM.x = categories, NMM.y = categories)
anno.mat <- df %>%
count(NMM.x, NMM.y)
confusion <- merge(combinations, anno.mat, by = c("NMM.x", "NMM.y"), all.x = TRUE) %>%
replace_na(list(n = 0)) %>%
pivot_wider(names_from = NMM.y, values_from = n, values_fill = 0, names_sort = TRUE) %>%
rename(NMM = NMM.x)
# Move these columns to the back/bottom columns and rows
for (to_move in c("other", "unmatched")) {
if (to_move %in% colnames(confusion)) {
confusion <- confusion %>%
arrange(if_else(NMM == to_move, 1, 0)) %>%
select(-to_move, everything(), to_move)
}
}
confusion.total <- confusion %>%
bind_rows(summarise(., across(where(is.numeric), sum), across(where(is.character), ~'total'))) %>%
rowwise() %>%
mutate(total = sum(c_across(where(is.numeric))),
NMM = as.factor(NMM)) %>%
ungroup()
return(list(confusion = confusion,
confusion.total = confusion.total))
}
cohens_kappa <- function(df, cat) {
collapsed <- df %>%
pivot_longer(cols = -NMM, names_to = "category", values_to = "value") %>%
group_by(if_else(NMM == cat, "agree", "other")) %>%
summarize(agree = sum(value[category == cat]),
other = sum(value[category != cat]),
.groups = "drop") %>%
rename(NMM = 1)
matrx <- as.matrix(collapsed[, -1])
p_o <- sum(diag(matrx)) / sum(matrx)
p_e <- sum(rowSums(matrx) * colSums(matrx)) / sum(matrx) ^ 2
kappa <- (p_o - p_e) / (1 - p_e)
return(list(p_o = p_o,
p_e = p_e,
kappa = kappa,
collapsed = matrx))
}
calculate_agreement <- function(df, nmm_values) {
nmm_values <- droplevels(nmm_values)
results <- list()
for (value in nmm_values) {
result <- cohens_kappa(df = df, cat = value)
results[[value]] <- result
}
agreement <- data.frame(Raw = sapply(results, function(x) round(x$p_o, 2)),
Chance = sapply(results, function(x) round(x$p_e, 2)),
Kappa = sapply(results, function(x) round(x$kappa, 2)))
return(agreement)
}
plot.agreement <- function(agreement, save.plot = FALSE) {
# Data for plots
agreement <- t(agreement)
colnames(agreement) <- gsub("\\.", "-", colnames(agreement))
if(max(agreement) < 0.92) {
ylim.upper <- max(agreement) * 1.3
} else {ylim.upper <- max(agreement) * 1.19}
ylim.lower <- min(min(agreement) * 1.3, 0)
if(save.plot) {
fname <- paste("plots/kappa_", tier, "_event_based.jpeg",sep="")
jpeg(fname, width = 500, height = 550, quality = 100)
barplot(agreement , beside=T, legend.text = T, col=c("tomato4", "steelblue" ,"grey90"),
ylim = c(ylim.lower, ylim.upper), ylab="Agreement", xlab = "Category")
dev.off()
} else {
barplot(agreement , beside=T, col=c("tomato4", "steelblue" ,"grey90"),
ylim = c(ylim.lower, ylim.upper), ylab="Agreement", xlab = "Category",
cex.names = 0.8, cex.axis = 0.8)
legend("topleft", legend = c("Raw", "Chance", "Kappa"),
col=c("tomato4", "steelblue" ,"grey90"),
bty = "n", pch=20 , pt.cex = 2, cex = 0.75,
horiz = TRUE, inset = c(0.05, -0.02))
}
}
plot.matched.annotations <- function(df, question, threshold = FALSE) {
df <- suppressWarnings(overlap(df))
if(threshold) {
df <- filter.drop.levels(df, df$Overlap >= Overlap.threshold)
}
df.question <- df %>% filter(Question == question)
bg_colors <- c("#C5CAE9", "#B2DFDB", "#FFE0B2", "#F8BBD0", "#F0F4C3", "#BBDEFB")
p <- ggplot(df.question,
aes(xmin = Begin.Frame.x,
xmax = End.Frame.x,
ymin = as.numeric(Annotator.x)-0.4,
ymax = as.numeric(Annotator.x)+0.4,
fill = NMM.x)) +
geom_rect(alpha = 1, color = "black", size = 0.2) +
geom_segment(data = df.question,
aes(x = (Begin.Frame.x + Frames.x/2),
y = as.numeric(Annotator.x),
xend = (Begin.Frame.y + Frames.y/2),
yend = as.numeric(Annotator.y)),
color = "red", linewidth = 0.5) +
geom_text(data = df.question,
aes(x = ((Begin.Frame.x + Begin.Frame.y + Frames.x/2 + Frames.y/2)/2)+6 ,
y = (as.numeric(Annotator.x) + as.numeric(Annotator.y))/2,
label = paste0(round(Overlap, 1), "%")),
color = "red",
size = 2.8,
fontface = "bold") +
labs(x = "Time (frames)", y = "Annotator") +
ggtitle(paste(tier, "Tier, Question", question)) +
scale_fill_manual(values = bg_colors) +
theme_bw() +
theme(panel.spacing = unit(0, "lines"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.ticks.y = element_blank()) +
scale_y_continuous(limits = c(0.55, 2.45),
breaks = c(1, 2),
labels=c(Annotator.a, Annotator.b))
return(p)
}
tier <- "eyebrows"
replace_value <- FALSE
Annotator.a <- "M"
Annotator.b <- "T"
Overlap.threshold <- 51
df <- init(tier, replace_value = replace_value)
df.matches <- matches(df)
q <- "01-NeutNeg-01"
plot.matched.annotations(df, q, threshold = FALSE)
plot.matched.annotations(df, q, threshold = TRUE)
confusion.matrices <- confusion.matrix(df.matches)
confusion <- confusion.matrices$confusion
confusion.matrices$confusion.total
agreement <- calculate_agreement(df = confusion,
nmm_values = confusion[confusion$NMM != "unmatched",]$NMM)
# Save confusion matrices
write.csv(confusion.matrices$confusion.total, paste("confusion/confusion_", tier, "_event_based.csv",sep=""), row.names=FALSE)
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ggplot2)
library(stringr)
library(ggstance)
library(tidyr)
library(irr)
init <- function(tier, replace_value = FALSE) {
file <- paste("annotations/", tier, ".csv",sep="")
df <- read.csv(file, stringsAsFactors = FALSE)
df <- df %>%
# Set up basic structure
rename_all(~ gsub("\\.\\.\\.ss.msec", "", .)) %>%
rename_all(~ gsub("NMM\\..*", "NMM", .)) %>%
mutate(Annotator = case_when(grepl("MO", File) ~ Annotator.a, # Adjust to own annotator label
grepl("TDR", File) ~ Annotator.b,  # Adjust to own annotator label
TRUE ~ NA_character_)) %>%
mutate_at('NMM', ~ str_replace(., "-", ".")) %>%
# Can be adjusted according to own needs, or removed
mutate(NMM = case_when(
replace_value & tier == "eye_shape" & NMM == "closed" ~ "neutral",
replace_value & tier %in% c("lips", "lip_corners") & NMM == "mouth.action" ~ "neutral",
TRUE ~ NMM)) %>%
mutate_if(is.character, as.factor) %>%
# Round times to 0.05 for whole number of frames (necessary for time-based annotations)
mutate(Begin.Time = round(Begin.Time / 0.05) * 0.05,
End.Time = round(End.Time / 0.05) * 0.05) %>%
# Fill time gaps between annotations, find first and last annotation
group_by(Question, Annotator) %>%
arrange(Begin.Time) %>%
mutate(time_diff = lead(Begin.Time) - End.Time) %>%
replace(is.na(.), 0) %>%
mutate(Begin.Time = ifelse(time_diff < 0, Begin.Time + time_diff, Begin.Time),
End.Time = ifelse(time_diff > 0, End.Time + time_diff, End.Time),
Duration = End.Time - Begin.Time,
First.Annotator = ifelse(row_number() == 1, 1, 0),
Last.Annotator = ifelse(row_number() == n(), 1, 0)) %>%
ungroup() %>%
# Ensure that the annotations for each question match in begin and end times
group_by(Question) %>%
mutate(Begin.Time.Min = min(Begin.Time, na.rm = TRUE),
End.Time.Max = max(End.Time, na.rm = TRUE),
Begin.Time = ifelse(((Begin.Time > Begin.Time.Min) & First.Annotator), Begin.Time.Min, Begin.Time),
End.Time = ifelse(((End.Time < End.Time.Max) & Last.Annotator), End.Time.Max, End.Time),
Duration = round(End.Time - Begin.Time, 2)) %>%
ungroup() %>%
# Calculate the frames (using 1-indexing)
mutate(Begin.Frame = ((Begin.Time - Begin.Time.Min) * 60),
End.Frame = Begin.Frame + (Duration * 60),
Frames = Duration * 60) %>%
arrange(Annotator, Question) %>%
mutate(ID = 1:nrow(df)) %>%
select(Question, ID, Annotator, NMM, Begin.Time, End.Time, Duration, Begin.Frame, End.Frame, Frames)
# In the event-based approach, we remove the neutral annotations, as these are not events
df <- filter.drop.levels(df, df$NMM != "neutral")
df$ID <- 1:nrow(df)
return(df)
}
overlap <- function(df) {
overlapping <- df %>%
inner_join(df, by = "Question", suffix = c(".x", ".y")) %>%
select(Question, ID.x, ID.y, NMM.x, NMM.y, Annotator.x, Begin.Frame.x, End.Frame.x, Frames.x, Annotator.y, Begin.Frame.y, End.Frame.y, Frames.y) %>%
mutate(end = pmin(End.Frame.x, End.Frame.y),
begin = pmax(Begin.Frame.x, Begin.Frame.y),
Overlap = round((end - begin) / pmax(Frames.x, Frames.y) * 100, 0),
Overlap.x = round((end - begin) / Frames.x * 100, 0),
Overlap.y = round((end - begin) / Frames.y * 100, 0),
Overlap.frame = round((end - begin), 0), .before = Annotator.x) %>%
filter(Annotator.x != Annotator.y,
End.Frame.x > Begin.Frame.y,
End.Frame.y > Begin.Frame.x,
Overlap > 0) %>%
select(-c(end, begin))
return(overlapping)
}
filter.drop.levels <- function(df, condition) {
df.filtered <- df %>%
filter(condition) %>%
droplevels()
return(df.filtered)
}
matches <- function(df) {
df.overlapping <- suppressWarnings(overlap(df))
df.overlapping.filtered <- filter.drop.levels(df.overlapping, df.overlapping$Overlap >= Overlap.threshold)
df.matches <- df.overlapping.filtered %>%
right_join(df, by = c("Question" = "Question", "ID.x" = "ID", "Annotator.x" = "Annotator", "NMM.x" = "NMM")) %>%
arrange(ID.x) %>%
# Fill in unmatched annotations
mutate(NMM.y = if_else(is.na(NMM.y), "unmatched", NMM.y),
Annotator.y = if_else(is.na(Annotator.y), if_else(Annotator.x == Annotator.a, Annotator.b, Annotator.a), Annotator.y),
ID.y = as.integer(if_else(is.na(ID.y), 0, ID.y))) %>%
# Swap values in ID, NMM, and Annotator columns if Annotator.x is Annotator.b
mutate(swap = if_else(Annotator.x == Annotator.b, TRUE, FALSE),
ID.xx = ID.x,
ID.yy = ID.y,
ID.x = if_else(swap, ID.yy, ID.x),
ID.y = if_else(swap, ID.xx, ID.y),
NMM.xx = NMM.x,
NMM.yy = NMM.y,
NMM.x = if_else(swap, NMM.yy, NMM.x),
NMM.y = if_else(swap, NMM.xx, NMM.y),
Annotator.x = if_else(swap, Annotator.a, Annotator.x),
Annotator.y = if_else(swap, Annotator.b, Annotator.y)) %>%
mutate_if(is.character, as.factor) %>%
select(Question, ID.x, ID.y, NMM.x, NMM.y, Annotator.x, Annotator.y) %>%
distinct()
return(df.matches)
}
confusion.matrix <- function(df) {
categories <- unique(c(levels(df$NMM.x), levels(df$NMM.y)))
combinations <- crossing(NMM.x = categories, NMM.y = categories)
anno.mat <- df %>%
count(NMM.x, NMM.y)
confusion <- merge(combinations, anno.mat, by = c("NMM.x", "NMM.y"), all.x = TRUE) %>%
replace_na(list(n = 0)) %>%
pivot_wider(names_from = NMM.y, values_from = n, values_fill = 0, names_sort = TRUE) %>%
rename(NMM = NMM.x)
# Move these columns to the back/bottom columns and rows
for (to_move in c("other", "unmatched")) {
if (to_move %in% colnames(confusion)) {
confusion <- confusion %>%
arrange(if_else(NMM == to_move, 1, 0)) %>%
select(-to_move, everything(), to_move)
}
}
confusion.total <- confusion %>%
bind_rows(summarise(., across(where(is.numeric), sum), across(where(is.character), ~'total'))) %>%
rowwise() %>%
mutate(total = sum(c_across(where(is.numeric))),
NMM = as.factor(NMM)) %>%
ungroup()
return(list(confusion = confusion,
confusion.total = confusion.total))
}
cohens_kappa <- function(df, cat) {
collapsed <- df %>%
pivot_longer(cols = -NMM, names_to = "category", values_to = "value") %>%
group_by(if_else(NMM == cat, "agree", "other")) %>%
summarize(agree = sum(value[category == cat]),
other = sum(value[category != cat]),
.groups = "drop") %>%
rename(NMM = 1)
matrx <- as.matrix(collapsed[, -1])
p_o <- sum(diag(matrx)) / sum(matrx)
p_e <- sum(rowSums(matrx) * colSums(matrx)) / sum(matrx) ^ 2
kappa <- (p_o - p_e) / (1 - p_e)
return(list(p_o = p_o,
p_e = p_e,
kappa = kappa,
collapsed = matrx))
}
calculate_agreement <- function(df, nmm_values) {
nmm_values <- droplevels(nmm_values)
results <- list()
for (value in nmm_values) {
result <- cohens_kappa(df = df, cat = value)
results[[value]] <- result
}
agreement <- data.frame(Raw = sapply(results, function(x) round(x$p_o, 2)),
Chance = sapply(results, function(x) round(x$p_e, 2)),
Kappa = sapply(results, function(x) round(x$kappa, 2)))
return(agreement)
}
plot.agreement <- function(agreement, save.plot = FALSE) {
# Data for plots
agreement <- t(agreement)
colnames(agreement) <- gsub("\\.", "-", colnames(agreement))
if(max(agreement) < 0.92) {
ylim.upper <- max(agreement) * 1.3
} else {ylim.upper <- max(agreement) * 1.19}
ylim.lower <- min(min(agreement) * 1.3, 0)
if(save.plot) {
fname <- paste("plots/kappa_", tier, "_event_based.jpeg",sep="")
jpeg(fname, width = 500, height = 550, quality = 100)
barplot(agreement , beside=T, legend.text = T, col=c("tomato4", "steelblue" ,"grey90"),
ylim = c(ylim.lower, ylim.upper), ylab="Agreement", xlab = "Category")
dev.off()
} else {
barplot(agreement , beside=T, col=c("tomato4", "steelblue" ,"grey90"),
ylim = c(ylim.lower, ylim.upper), ylab="Agreement", xlab = "Category",
cex.names = 0.8, cex.axis = 0.8)
legend("topleft", legend = c("Raw", "Chance", "Kappa"),
col=c("tomato4", "steelblue" ,"grey90"),
bty = "n", pch=20 , pt.cex = 2, cex = 0.75,
horiz = TRUE, inset = c(0.05, -0.02))
}
}
plot.matched.annotations <- function(df, question, threshold = FALSE) {
df <- suppressWarnings(overlap(df))
if(threshold) {
df <- filter.drop.levels(df, df$Overlap >= Overlap.threshold)
}
df.question <- df %>% filter(Question == question)
bg_colors <- c("#C5CAE9", "#B2DFDB", "#FFE0B2", "#F8BBD0", "#F0F4C3", "#BBDEFB")
p <- ggplot(df.question,
aes(xmin = Begin.Frame.x,
xmax = End.Frame.x,
ymin = as.numeric(Annotator.x)-0.4,
ymax = as.numeric(Annotator.x)+0.4,
fill = NMM.x)) +
geom_rect(alpha = 1, color = "black", size = 0.2) +
geom_segment(data = df.question,
aes(x = (Begin.Frame.x + Frames.x/2),
y = as.numeric(Annotator.x),
xend = (Begin.Frame.y + Frames.y/2),
yend = as.numeric(Annotator.y)),
color = "red", linewidth = 0.5) +
geom_text(data = df.question,
aes(x = ((Begin.Frame.x + Begin.Frame.y + Frames.x/2 + Frames.y/2)/2)+6 ,
y = (as.numeric(Annotator.x) + as.numeric(Annotator.y))/2,
label = paste0(round(Overlap, 1), "%")),
color = "red",
size = 2.8,
fontface = "bold") +
labs(x = "Time (frames)", y = "Annotator") +
ggtitle(paste(tier, "Tier, Question", question)) +
scale_fill_manual(values = bg_colors) +
theme_bw() +
theme(panel.spacing = unit(0, "lines"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.ticks.y = element_blank()) +
scale_y_continuous(limits = c(0.55, 2.45),
breaks = c(1, 2),
labels=c(Annotator.a, Annotator.b))
return(p)
}
tier <- "eyebrows"
replace_value <- FALSE
Annotator.a <- "M"
Annotator.b <- "T"
Overlap.threshold <- 51
df <- init(tier, replace_value = replace_value)
df.matches <- matches(df)
q <- "01-NeutNeg-01"
plot.matched.annotations(df, q, threshold = FALSE)
plot.matched.annotations(df, q, threshold = TRUE)
library("irrkappa")
setwd("~/Desktop/SignLab")
df <- init("eyebrows")
df.matches <- matches(df)
setwd("~/Desktop/SignLab/irrkappa")
devtools::document()
?matches
df.matches <- matches(df)
library("irrkappa")
?matches
devtools::document()
?matches
library("irrkappa")
?matches
library("irrkappa")
setwd("~/Desktop/SignLab")
df <- init("eyebrows")
df.matches <- matches(df)
rlang::last_trace()
